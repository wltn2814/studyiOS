//: [Previous](@previous)

import Foundation
import Swift

//: [Next](@next)

/* 익스텐션 */

// 1. 익스텐션

// 익스텐션(Extension)은 스위프트의 강력한 기능 중 하나
// 익스텐션은 구조체, 클래스, 열거형, 프로토콜 타입에 새로운 기능을 추가하는 기능
// 기능을 추가하려는 타입의 구현된 소스 코드를 알지 못하거나 볼 수 없다 해도 타입만 알고 있다면 그 타입의 기능을 확장할 수도 있습니다.

// <<스위프트의 익스텐션이 타입에 추가할 수 있는 기능>>
// 연산 타입 프로퍼티 / 연산 인스턴스 프로퍼티
// 타입 메서드 / 인스턴스 메서드
// 이니셜라이저
// 서브스크립트
// 중첩 타입
// 특정 프로토콜을 준수할 수 있도록 기능 추가
// ** 익스텐션은 타입에 새로운 기능을 추가할 수는 있지만, 기존에 존재하는 기능을 재정의할 수는 없음

// <<클래스의 상속과 익스텐션 비교>>
// 이 둘은 비슷해보이지만, 실제 성격은 많이 다름
// 클래스의 상속은 클래스 타입에서만 가능하지만 익스텐션은 구조체, 클래스, 프로토콜 등에 적용이 가능
// 클래스의 상속은 특정 타입을 물려받아, 하나의 새로운 타입을 정의 -> 추가 기능을 구현 : 수직 확장
// 익스텐션은 기존의 타입에 기능을 추가 -> 수평 확장
// 상속을 받으면 기존 기능 재정의 가능, 익스텐션은 재정의 불가능
// 상황과 용도에 맞게 상속과 익스텐션 선택 사용

//          상속              익스텐션
// 확장    수직 확장            수평 확장
// 사용   클래스 타입      클래스, 구조체, 프로토콜, 제네릭 등 모든 타입
// 재정의    가능                불가능

// <<익스텐션 활용>>
// 익스텐션을 사용하는 대신 원래 타입을 정의한 소스에 기능을 추가
// 외부 라이브러리, 프레임워크를 가져다 쓰는 경우, 원본 소스 수정 불가능
// 외부에서 가져온 타입에 원하는 기능을 추가하고자 할 때 사용
// 상속 X, 구조체와 열거형에도 기능 추가 가능
// 매우 편리한 기능

// 모든 타입(구조체, 열거형, 클래스, 프로토콜, 제네릭 타입 등)에 적용 가능
// 익스텐션을 통해 모든 타입에 연산 프로퍼티, 메서드, 이니셜라이저, 서브스크립트, 중첩 데이터 타입 등 추가
// 익스텐션은 프로토콜과 함께 사용하면 강력한 기능 선사
// 프로토콜 중심 프로그래밍에 대해 더 알아보기

// 2. 정의
// extension 키워드를 사용하여 정의
// extension 확장할 타입 이름 {
    /* 타입에 추가될 새로운 기능 구현 */
// }
// 익스텐션은 기존에 존재하는 타입이 추가적으로 다른 프로토콜을 채택할 수 있도록 확장할 수 있음
// 동일한 방법으로 프로토콜 이름 나열

//extension 확장할 타입 이름: 프로토콜1, 프로토콜2, 프로토콜3... {
    /* 프로토콜 요구사항 구현 */
//}

// 스위프트 라이브러리를 살펴보면 익스텐션이 굉장히 많이 사용됨
// Double 아팁에는 수많은 프로퍼티와 메서드, 이니셜라이저가 정의되어 있음. 프로토콜을 채택하고 있을것이라고 예상됨
// 실제로 Double타입은 익스텐션으로 대부분 구현되어있음
// Double외에도 다른 타입의 정의와 익스텐션을 찾아보면 더 많은 예를 볼 수 있음

// 3. 구현
// <<연산 프로퍼티 추가>>
// 아래 익스텐션은 Int 타입에 두 개의 연산 프로퍼티를 추가한 것
// Int 타입의 인스턴스가 홀수인지 짝수인지 판별하여 Bool타입으로 알려주는 연산 프로퍼티
// 익스텐션으로 Int타입에 추가해준 연산 프로퍼티는 Int타입의 어떤 인스턴스에도 사용이 가능
// 인스턴스 연산 프로퍼티를 추가할 수 있음. static 키워드를 사용하여 타입 연산 프로퍼티도 추가 가능

extension Int{
    var isEven: Bool {
        return self % 2 == 0
    }
    var isOdd: Bool{
        return self % 2 == 1
    }
}

print(1.isEven)
print(2.isEven)
print(1.isOdd)
print(2.isOdd)

var number: Int = 3
print(number.isEven)
print(number.isOdd)

number = 2
print(number.isEven)
print(number.isOdd)

// <<메서드 추가>>
// 메서드 익스텐션을 통해 Int 타입에 인스턴스 메서드인 multiply(by:) 메서드를 추가했음
// 여러 기능을 여러 익스텐션 블록으로 나눠서 구현해도 문제 X
// 관련된 기능별로 하나의 익스텐션 블록에 묶어줘도 좋음

extension Int{
    func multiply(by n: Int) -> Int{
        return self*n
    }
}
print(3.multiply(by:2))
print(4.multiply(by:5))

number = 3
print(number.multiply(by:2))
print(number.multiply(by:3))

// <<이니셜라이저 추가>>
// 인스턴스를 초기화(이니셜라이즈)할 때 인스턴스 초기화에 필요한 다양한 데이터를 전달받을 수 있도록 여러 종류의 이니셜라이저를 만들 수 있음
// 타입 정의부에 이니셜라이저를 추가하지 않아도 익스텐션을 통해 추가할 수 있음
// 익스텐션으로 클래스 타입에 편의 이니셜라이저는 추가할 수 있지만, 지정 이니셜라이저는 추가할 수 없음
// 지정 이니셜라이저와 디이니셜라이저는 반드시 클래스 타입의 구현부에 위치 (값 타입 상관 X)

extension String{
    init(int:Int) {
        self = "\(int)"
    }
    
    init(double: Double){
        self = "\(double)"
    }
}

let stringFromInt: String = String(int:100)

let stringFromDouble: String = String(double: 100.0)

// **익스텐션을 활용하면 다양하고 강력한 기능을 구현할 수 있지만, 해당 타입에 적합한 익스텐션을 구현하도록 주의해야함
